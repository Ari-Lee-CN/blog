# js继承

## 原型链实现继承

> 通过对象字面量方式创建原型方法会破坏之前的原型链，相当于重写了原型链

~~~JavaScript
subType.prototype = new SubType();

subType.prototype = {
    getSubValue(){
        return
    },
    
    someOtherMethod(){
        return
    }
}
~~~

这相当于将prototype更换了指针指向，原型链就断了

### 缺点

* 原型引用值全部实例共享，并且修改也会映射到实例上
* 子类型无法给父类型传参

## 其他实现形式

### 盗用构造函数/经典伪装

思路：不采用原型链的形式，而是使用apply、call来借用父类型的构造函数，使得每个实例有着自己的属性，通过对this进行操作，也可以实现子类型向父类型传参

缺点：使用构造函数而不是原型，导致了方法必须写在构造函数上，无法重用，而且对于原型上的方法，子类访问不到。

### 组合继承

看作class前身

将属性定义在构造函数内，将方法定义在原型中

### 原型式继承/object.create()

其实就是实现了复制（浅复制）

~~~JavaScript
function object(o){
    function F(){}
    F.prototype = o;
    return new F()
}
~~~

~~~javascript
let anotherPerson = Object.create(person,{
    name:{
        
    }
})
~~~

第一个参数为复制的对象，第二个参数是添加的属性



但是只要涉及原型继承的，引用值就会共享，牵一发而动全身，注意！

### 寄生式继承

实际上就是在函数内部克隆一下进行修改，相似的思路

### 寄生式组合继承

组合继承中父类构造函数分别在创建实例和继承方法时各被调用一次

在创建实例对象时只需要重写原型就行了，因此可以使用寄生继承，一共使用了三种继承思想。

### 类就是寄生式组合继承的语法糖