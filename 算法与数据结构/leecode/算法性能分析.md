# 算法性能分析

## 时间复杂度

时间复杂度是一个函数它定性描述该算法的运行时间，方便开发者估计出程序运行的答题时间，通常会估计算法的操作单元数量来表示程序小号的实践，默认cpu的每个单元运行消耗的时间相同。
		假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率想用，这被称为算法的渐进时间复杂度，简称时间复杂度，记为￥O(f(n)$)。

### 大O

1. 大O是用来表示上界的，当用它来作为算法的最坏情况运行时间的上界，就是对任意数据书如地运行时间的上界。

   > 以插入排序法为例，顺序排序的复杂度为$O(n)$，逆序排列的是$O(n^2)$，但是一般情况下复杂度为$O(n^2)$

2. 是否是一般情况影响着算法的时间复杂度，探讨算法实现和性能时，要想着数据用例的不同。
3. 大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，因此不用去考虑常数项系数

#### 复杂度表达式的化简

~~~
O(2*n^2 + 10*n +1000)
去掉常数
O(n^2 + n)
保留最高项，去掉数量级小一级的n
O(n^2)
得到最后结果
~~~

同时logn是忽略底数的，因为底数之间的转化可以通过乘以一个常数项进行转化

### 算法超时

运行速度主要取决于cpu配置，1hz进行一次执行，不能将一个时钟周期理解为一次cpu计算

>1. cpu执行每一条指令所需时间并不相同，例如加法和惩罚
>2. 因为内存管理的缓存技术，频繁访问相同地址的数据和访问不相邻元素所需时间也有所不同
>3. 计算机会同时运行多个程序，每个程序嗨哟不同的进程线程在抢占资源

估计程序的运行时间是一门基本功，因此可以用一个类似时间复杂度的代码来进行测试，估计1s内该算法能运行多少次。

### 关于递归算法的探索

## 空间复杂度分析j

1. 记作$S(n)=O(f(n))$
2. 是程序运行时占用内存大小并非是可执行文件的大小
3. 由于编译器的内存对齐及编程语言容器的底层实现等都会直接影响到程序内存的开销，所以口昂见复杂度是预先答题评估程序内存使用的大小
4. 随着n的变化，占用内存大小也在相应的改变

## 内存管理

#### 垃圾回收（GC）

1. 引用计数垃圾回收：当对象没有被其他对象引用的时候就会被认为是不被需要的，会被垃圾回收机制回收
2. 标记-清除算法：该算法将对象是否不再需要简化定义为对象是否可以获得，该算法假定设置一个叫做root的对象（js中是全局对象），垃圾回收器将定期从根开始，找所有从跟开始引用的对象，然后找这些对象引用的对象....

GC会是终端代码执行，停止其他操作，耗时有时候会在100ms以上，因此引入了分代回收、增量GC两种优化方式

粉黛回收：通过对象的使用频率，存在市场区分新生代和老生代对象。多回收新生代区，少回收老生代区，减少每次需遍历对象，减少耗时

增量GC，遍历回收操作拆分运行，减少中断时间，会增大上下文切换开销

#### 内存对齐的存在

存在原因

1. 平台原因，不是所有的硬件平台都能访问任意内存地址上的内衣数据，某些硬件平台只能在某些地址处取一些特定类型的数据，否则会抛出硬件异常
2. 硬件原因：会提升cpu访问内存的速度

cpu读取内存是一块一块来进行读取的而不是一个个的来读取的，通过内存对齐，将在内存中适当留白，使得cpu可以一次读取，减少了后续合并不同块的操作，虽然多占用了内存资源，但是大大提升了cpu读取速度



