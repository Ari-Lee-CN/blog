# 回溯算法
>回溯算法可以抽象为树形结构，回溯法解决的都是在集合中递归查找子集，集合的大小构成了树的宽度，递归的深度都构成书的深度
> n叉树问题

## 模板
~~~C
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
~~~

## 组合问题
~~~js
function combine(n: number, k: number): number[][] {
    let resArr: number[][] = [];
    function backTracking(n: number, k: number, startIndex: number, tempArr: number[]): void {
        if (tempArr.length === k) {
            resArr.push(tempArr.slice());
            return;
        }
        for (let i = startIndex; i <= n - k + 1 + tempArr.length; i++) {
            tempArr.push(i);
            backTracking(n, k, i + 1, tempArr);
            tempArr.pop();
        }
    }
    backTracking(n, k, 1, []);
    return resArr;
};
~~~
* 思路就是迭代+for循环+回溯
* 需要n来限制数组大小 k来限制数字个数 startIndex来限制指针指向的节点位置 tempArr来记录已经保存的数值并且回溯

组合问题三
~~~js
function combinationSum3(k: number, n: number): number[][] {
    const resArr: number[][] = [];
    function backTracking(k: number, n: number, sum: number, startIndex: number, tempArr: number[]): void {
        if (sum > n) return;
        if (tempArr.length === k) {
            if (sum === n) {
                resArr.push(tempArr.slice());
            }
            return;
        }
        for (let i = startIndex; i <= 9 - (k - tempArr.length) + 1; i++) {
            tempArr.push(i);
            backTracking(k, n, sum + i, i + 1, tempArr);
            tempArr.pop();
        }
    }
    backTracking(k, n, 0, 1, []);
    return resArr;
};
~~~
sum是实时的和，而n才是真正的目标和