# 疑问集

## 为什么定义在类里的事件响应方法的this会指向全局作用域而不是类的实例

解：我们首先要清楚类是怎么发展过来的，类是继承加上那个（）发展来的

而类就是一个构造函数加上一个（），这样一旦用new调用，那么就创建一个实例对象，把这些东西装进去。

由此看来，没new之前，作用域是全局变量，然后严格模式下就会变成undefined，一旦new之后实例化，this就指向了实例。

所以由此看来，constructor函数内部就是原型、其余的都是定义在实例中的

## 为什么react简化过程中，可以使用箭头函数而不能使用function来定义，this？

如果使用function就是定义在实例上，但又有个问题是，你的this访问的是你这个方法，但是state状态等只有在实例或者原型上能访问到，所以用箭头函数可以自动将this指向它外侧的作用域，也就是实例，因为他是作用在实例上的方法

## 展开运算符没学过啊，原生中不能展开一个对象对象，在react中可以实现（但是仅仅适用于标签属性的传递）

## 为什么 getDerivedStateFromProps()要用静态方法

。 既然已经结束，componentDidMount 自然是连接异步和非纯函数的最佳连接点。

我们必须明白的是，生命周期方法出于性能和灵活性的原因不断调整，并且完全在 React 工程师的控制之下。这不仅适用于 React，事实上它适用于任何第三方代码的流程。因此，引入不纯函数或异步调用可能会导致问题，因为您将迫使 React 工程师谨慎进行优化。

例如如果 React 工程师决定在单个生命周期流中运行两次或更多次 getDerivedStateFromProps，那么不纯函数和异步调用都会被触发两次或更多次，直接影响应用程序的某些部分。然而对于纯函数，这不会成为问题，因为它们只返回值，并且由 React 工程师决定在多个 getDerivedStateFromProps 调用中的过程(他们可以简单地丢弃所有返回值直到最后一次调用并利用最后一个)。

另一个例子是，如果 React 工程师决定使渲染调用异步会怎样。 也许他们想要将所有的渲染调用(从父级到所有嵌套的子级)集中起来并异步触发它们以提高性能。

现在这意味着在渲染方法中或在它之前编写的异步调用(如在构造函数或 getDerivedStateFromProps 中)可能会干扰渲染过程，因为异步过程完成的不可预测性。一个可以在另一个之前或之后完成，不可预测地触发它们各自的回调。这种不可预测性可以通过多重渲染、不可预测状态等形式反射(reflect)出来。

重要的是，这两个想法不仅仅是示例，而是由 React 工程师表达为 future 可能的优化方法。在这里阅读:<https://stackoverflow.com/a/41612993/923372>

尽管如此，React 工程师知道那里的开发人员仍然可以编写异步代码或不纯的函数，为了阻止这种情况，他们将生命周期方法之一设为静态。 构造函数、render、getSnapshotBeforeUpdate、componentDidMount 和 componentDidUpdate 方法不能是静态的，因为它们需要访问实例属性，如 this.state、this.props、其他自定义事件处理程序等(构造函数初始化它们，render 使用它们来控制 UI逻辑，其他生命周期方法需要这些来与早期状态进行比较)

但是，考虑到 getDerivedStateFromProps，如果先前的 props 与当前的 props 不同，则提供此钩子(Hook)仅用于返回状态的更新克隆。根据这个定义，这听起来很纯粹，不需要任何对实例属性的访问。让我们分析一下原因。

为了让这个钩子(Hook)工作，开发者首先需要将之前的 props 存储在实例状态中(比方说，在构造函数调用中)。这是因为 getDerivedStateFromProps 接收实例状态以及新的 props 作为参数。然后，开发人员可以继续比较所需的属性并返回状态的更新克隆(无需访问 this.props 或 this.state)。

通过将 getDerivedStateFromProps 设为静态，React 不仅会强制您编写纯函数，还会使编写异步调用变得困难，因为您无法从该方法中访问任何实例。 通常异步调用会提供一个回调，它很可能是一个实例方法。

现在这并不意味着开发人员不能编写它们，相反，这只是使其变得困难并被迫远离此类方法。

一个简单的经验法则是远离不纯和异步的函数 第三方诱导流量持续时间的方法。 您应该只在此类流程结束时引入此类方法。

后续可以进一步研究一下
