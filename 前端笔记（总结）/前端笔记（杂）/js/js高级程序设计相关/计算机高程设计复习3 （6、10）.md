# 计算机高程设计复习3 （6、10）

## 关于执行时机

![image-20220107201557231](C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20220107201557231.png)

* 解释：因为seTimeout是异步执行函数，所谓异步执行函数就是如果

## 简单几个小题

![image-20220107194010495](C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20220107194010495.png)

思路1，getDay()函数转化

思路2，使用   xxx ？  ：表达式依次判断

思路3，将日期之间的对应想象为键值对，然后建立一个数组，按照下标得到对应的日期

## 重点记忆

数组操作方法

map、set 弱映射记忆

作用域链的创建过程

闭包的原理、缺点、this指向

## 零碎知识点

* 数组空位最好用undefined表示
* **作用域链的创建过程**
  函数执行时，每个执行上下文中都会有一个包含其中变量的对象（全局作用域位变量对象，局部作用域为活动对象，只在执行期间存在），定义一个函数时，会创建作用域链，预装载全局变量对象，保存在[scope]中，然后调用这个函数时，会为它创建对应上下文，赋值[scope]创建作用域链，创建活动对象推入作用域链顶。
* 立即调用函数
* 

## Array数组

### 小知识

* 数组空位最好用undefined表示
* length方法可以用来增加或者删除数组元素
* isArray()检测是否为数组
* 迭代器方法 keys()  values()  entries()

### 创建数组方式

1. 构造函数方式创建   new 可忽略
2. 数组字面量形式
3. from和of静态方法
   from 将类数组结构转换为数组实例（执行浅复制）
   of将一组参数转换为数组实例

### 数组操作方法

#### 复制填充

fill()   copyWithin

#### 转换方法

toLocaleString()  toString()  返回相应的字符串，都是由相应字符串拼接而成

 valueOf() 返回原本的

join()增加分隔符

#### 数据结构方法

* 栈方法：push  pop

* 队列法  shift  push

* 排序  reverse  sort

* 操作方法  可以利用string引用类型上的方法

  > conact()实现不同数组之间的拼接，
  >
  > > 数组会被强制打平，也就是被转换，
  > > 需要在被融合的数组上设置Symbol.isContactSpreadable()
  >
  > splice() 向数组中插入元素，可以同时实现**删除、插入、替换**
  >
  > > splice（起始位置、删除数量、插入元素）

* 搜索方法 

  1. 也是继承自String indexOf lasIndexOf include
  2. 使用断言函数 find() findIndex()

* 迭代方法

  1. every 每个都符合要求
  2. filter 符合要求的组成数组返回
  3. forEach 每个元素执行
  4. map 返回符合要求的执行结果
  5. some 是否有符合要求的

* 归并方法  reduce reduceRight

## Map

### 零碎知识点

* map与object之间的不同在于 map实例会维护键值对的插入顺序，可以通过entries()方法来获取迭代器
* 

### 基本操作方法

1. set 增加键值对
   初始化声明

   ~~~js
   const m = new Map().set('key1','vall');
   
   m.set('key2','val2')
    .set('key3','val3');
   
   ~~~

   

2. get has 查询键值对

3. delete clear 删除键值对

4. keys values 返回键值

### 与object对比

1. map占用空间内存更小，提升性能
2. 涉及大量插入操作时，map好一些
3. 查询时，键值对多的时候，用map性能高；键值对少的时候object
4. 删除性能map好一大截

### 弱映射暂且不看

主要原理在于，键弱引用，键也是值的引用，值不是弱引用，有利于垃圾回收

## set

### 基本操作方法

1. add 增加值
2. has查询值
3. size元素数量
4. delete clear删除

## set、map、weakset、weakmap总结

Set：

- 成员唯一、无序且不重复。
- [value, value]，键值与键名是一致的（或者说只有键值，没有键名）。
- 可以遍历，方法有：add、delete、has。

WeakSet：

- 成员都是对象。
- 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏。
- 不能遍历，方法有add、delete、has。

Map：

- 本质上是键值对的集合，类似集合。
- 可以遍历，方法很多可以跟各种数据格式转换。

WeakMap：

- 只接受对象作为键名（null除外），不接受其他类型的值作为键名。
- 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的。
- 不能遍历，方法有get、set、has、delete。

## 函数基础

### 零散知识点

* [箭头函数位于原型链最底部，是继承来的，但是没prototype](https://blog.csdn.net/weixin_42798473/article/details/105319353)、不是构造函数，也没有this，没有caller、arguments、prototype等
* arguments对象是类数组对象，存储了调用函数时传入的参数值。非严格模式下arguments会存储参数初始值，并且修改可以相应反映到参数中，但是这是单向的，修改参数不会影响arguments。严格模式下，二者是相互独立的，因为二者占用了两块不同的内存
* 函数可以作为值来使用，但是不能带括号，带括号就是执行的意思

### 定义方法

1. 声明一个 funtcion 
2. 调用构造函数、new一个 解释好多次，性能差
3. ‘箭头函数  
4. 匿名函数

### 函数内部

### caller

指向执行过程中被调用的那个函数

> arguments对象身上有一个callee对象，二者指向相同，也都是在执行过程中被调用的，但是区别在于位置不同，并且caller主要用于this等，callee主要用于匿名函数递归
>
> 严格模式下不能给它赋值

### arguments

* callee 见caller
* 调用时产生

### this

### new.target

用来指向被调用的构造函数

### length

命名参数个数

### prototype

**apply与call控制函数调用上下文（this）的能力**

将任意对象设置为任意函数的作用域，对象无需关心方法

bind() 创建一个新的函数实例，this值绑定到传给bind()的对象

## 匿名函数的意义

声明函数时，要给堆内存空间起名字
		匿名函数就不需要起名字，而是在堆空间保存一个地址

**存在赋值操作，要注意声明不会提升，注意书写顺序**

### 尾调用优化

执行条件：必须在严格模式下进行

尤其对于递归操作有较大的性能提升，因为递归操作会调用大量的没有必要的栈尾

## 闭包

* 引用了另一个函数作用域中变量的函数

* 原理：闭包会将其包含的函数的活动对象（局部变量）添加到自己的作用域中
* 缺点：闭包引用了其他函数的作用域，使得垃圾回收机制无法生效，食用过多会占用内存

* 内存泄露问题
* that的巧妙使用

## 私有与共有变量与模块模式

### 两种私有变量处理方式

暂时懒得写了。。以后有必要再补吧

